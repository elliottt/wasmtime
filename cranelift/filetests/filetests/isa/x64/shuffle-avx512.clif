test compile precise-output
set enable_simd
target x86_64 has_avx512vl has_avx512vbmi

function %shuffle_in_bounds(i8x16, i8x16) -> i8x16 {
block0(v0: i8x16, v1: i8x16):
    ;; pick the second lane of v1, the rest use the first lane of v0
    v2 = shuffle v0, v1, 0x11000000000000000000000000000000
    return v2
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   movdqa xmm5, xmm0
;   movdqu xmm0, const(0)
;   movdqa xmm6, xmm5
;   vpermi2b xmm0, xmm0, xmm6, xmm1
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   movdqa xmm5, xmm0
;   movdqu xmm0, xmmword ptr [rip + 0x10]
;   movdqa xmm6, xmm5
;   vpermi2b xmm0, xmm6, xmm1
;   mov rsp, rbp
;   pop rbp
;   ret
;   add byte ptr [rax], al
;   add byte ptr [rax], al
;   add byte ptr [rax], al
;   add byte ptr [rax], al
;   add byte ptr [rax], al
;   add byte ptr [rax], al
;   add byte ptr [rax], al
;   add byte ptr [rax], al

function %f3(i8x16, i8x16) -> i8x16 {
block0(v0: i8x16, v1: i8x16):
    v2 = shuffle v0, v1, [3 0 31 26 4 6 12 11 23 13 24 4 2 15 17 5]
    return v2
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   movdqa xmm5, xmm0
;   movdqu xmm0, const(0)
;   movdqa xmm6, xmm5
;   vpermi2b xmm0, xmm0, xmm6, xmm1
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   movdqa xmm5, xmm0
;   movdqu xmm0, xmmword ptr [rip + 0x10]
;   movdqa xmm6, xmm5
;   vpermi2b xmm0, xmm6, xmm1
;   mov rsp, rbp
;   pop rbp
;   ret
;   add byte ptr [rbx], al
;   add byte ptr [rdi], bl
;   sbb al, byte ptr [rsi + rax]
;   or al, 0xb

