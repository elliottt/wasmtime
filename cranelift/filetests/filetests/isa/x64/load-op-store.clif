test compile precise-output
target x86_64

function %f0(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = iadd v2, v1
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   add dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   add dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %f1(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = iadd v1, v2
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   add dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   add dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %f2(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = isub v2, v1
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   sub dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   sub dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %f3(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = band v2, v1
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   and dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   and dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %f4(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = band v1, v2
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   and dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   and dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %f5(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = bor v2, v1
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   or dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   or dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %f6(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = bor v1, v2
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   or dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   or dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %f7(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = bxor v2, v1
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   xor dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   xor dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %f8(i64, i32) {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0+32
  v3 = bxor v1, v2
  store v3, v0+32
  return
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   xor dword ptr [rdi + 0x20], esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   xor dword ptr [rdi + 0x20], esi ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

