test compile precise-output
target x86_64

function %add_from_mem_u32_1(i64, i32) -> i32 {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0
  v3 = iadd.i32 v2, v1
  return v3
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   mov rax, rsi
;   add eax, eax, dword ptr [rdi + 0x0]
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   mov rax, rsi
;   add eax, dword ptr [rdi] ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %add_from_mem_u32_2(i64, i32) -> i32 {
block0(v0: i64, v1: i32):
  v2 = load.i32 v0
  v3 = iadd.i32 v1, v2
  return v3
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   mov rax, rsi
;   add eax, eax, dword ptr [rdi + 0x0]
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   mov rax, rsi
;   add eax, dword ptr [rdi] ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %add_from_mem_u64_1(i64, i64) -> i64 {
block0(v0: i64, v1: i64):
  v2 = load.i64 v0
  v3 = iadd.i64 v2, v1
  return v3
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   mov rax, rsi
;   add rax, rax, qword ptr [rdi + 0x0]
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   mov rax, rsi
;   add rax, qword ptr [rdi] ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %add_from_mem_u64_2(i64, i64) -> i64 {
block0(v0: i64, v1: i64):
  v2 = load.i64 v0
  v3 = iadd.i64 v1, v2
  return v3
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   mov rax, rsi
;   add rax, rax, qword ptr [rdi + 0x0]
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   mov rax, rsi
;   add rax, qword ptr [rdi] ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %add_from_mem_not_narrow(i64, i8) -> i8 {
block0(v0: i64, v1: i8):
  v2 = load.i8 v0
  v3 = iadd.i8 v2, v1
  return v3
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   movzx rax, byte ptr [rdi + 0x0]
;   add eax, eax, esi
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   movzx rax, byte ptr [rdi] ; trap: heap_oob
;   add eax, esi
;   mov rsp, rbp
;   pop rbp
;   ret

function %no_merge_if_lookback_use(i64, i64) -> i64 {
block0(v0: i64, v1: i64):
  v2 = load.i64 v0
  v3 = iadd.i64 v2, v0
  store.i64 v3, v1
  v4 = load.i64 v3
  return v4
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   mov r8, qword ptr [rdi + 0x0]
;   lea r9, qword ptr [r8 + rdi]
;   mov qword ptr [rsi + 0x0], r9
;   mov rax, qword ptr [r8 + rdi]
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   mov r8, qword ptr [rdi] ; trap: heap_oob
;   lea r9, [r8 + rdi]
;   mov qword ptr [rsi], r9 ; trap: heap_oob
;   mov rax, qword ptr [r8 + rdi] ; trap: heap_oob
;   mov rsp, rbp
;   pop rbp
;   ret

function %merge_scalar_to_vector(i64) -> i32x4 {
block0(v0: i64):
  v1 = load.i32 v0
  v2 = scalar_to_vector.i32x4 v1

  jump block1
block1:
  return v2
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   movss xmm0, qword ptr [rdi + 0x0]
;   jmp label1
; block1:
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   movss xmm0, dword ptr [rdi] ; trap: heap_oob
; block2: ; offset 0x8
;   mov rsp, rbp
;   pop rbp
;   ret

function %cmp_mem(i64) -> i64 {
block0(v0: i64):
  v1 = load.i64 v0
  v2 = icmp eq v0, v1
  v3 = uextend.i64 v2
  return v3
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   cmp rdi, qword ptr [rdi + 0x0]
;   setz dl
;   movzx rax, dl
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   cmp rdi, qword ptr [rdi] ; trap: heap_oob
;   sete dl
;   movzx rax, dl
;   mov rsp, rbp
;   pop rbp
;   ret

function %cmp_mem_zero(i64) -> i8 {
block0(v0: i64):
  v1 = load.i64 v0
  v2 = icmp_imm eq v1, 0
  return v2
}

; VCode:
;   push rbp
;   mov rbp, rsp
; block0:
;   mov rcx, qword ptr [rdi + 0x0]
;   test rcx, rcx
;   setz al
;   mov rsp, rbp
;   pop rbp
;   ret
; 
; Disassembled:
; block0: ; offset 0x0
;   push rbp
;   mov rbp, rsp
; block1: ; offset 0x4
;   mov rcx, qword ptr [rdi] ; trap: heap_oob
;   test rcx, rcx
;   sete al
;   mov rsp, rbp
;   pop rbp
;   ret

